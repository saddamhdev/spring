à¦ à¦¿à¦• à¦†à¦›à§‡, à¦šà¦² **`@Service` à¦¨à¦¾ à¦¦à¦¿à§Ÿà§‡ manual bean à¦¬à¦¾à¦¨à¦¾à¦¨à§‹à¦Ÿà¦¾** à¦à¦•à¦¦à¦® **real + interview-ready** à¦­à¦¾à¦¬à§‡ à¦¦à§‡à¦–à¦¿ ğŸ”¥

---

## ğŸ§© Manual Bean à¦®à¦¾à¦¨à§‡ à¦•à§€?

Spring-à¦•à§‡ à¦¤à§à¦®à¦¿ à¦¨à¦¿à¦œà§‡ à¦¬à¦²à§‡ à¦¦à¦¾à¦“:

> â€œà¦à¦‡ class-à¦Ÿà¦¾ bean à¦¬à¦¾à¦¨à¦¾à¦“, lifecycle à¦¤à§à¦®à¦¿ handle à¦•à¦°à§‹â€

à¦à¦Ÿà¦¾ à¦•à¦°à¦¾ à¦¹à§Ÿ `@Configuration` + `@Bean` à¦¦à¦¿à§Ÿà§‡à¥¤

---

## âœ… Step-by-Step Example

### 1ï¸âƒ£ Service class (à¦•à§‹à¦¨à§‹ annotation à¦¨à§‡à¦‡)

```java
public class UserService {

    public String getUserName(Long id) {
        return "User-" + id;
    }
}
```

---

### 2ï¸âƒ£ Configuration class

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public UserService userService() {
        return new UserService();
    }
}
```

ğŸ“Œ à¦à¦‡ `@Bean` method-à¦Ÿà¦¾à¦‡ Spring-à¦•à§‡ à¦¬à¦²à§‡:

```
UserService â†’ Spring Bean
```

---

### 3ï¸âƒ£ Controller (autowire à¦•à¦¾à¦œ à¦•à¦°à¦¬à§‡)

```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id) {
        return userService.getUserName(id);
    }
}
```

âœ” à¦ªà§à¦°à§‹à¦ªà§à¦°à¦¿ à¦•à¦¾à¦œ à¦•à¦°à¦¬à§‡
âœ” à¦•à§‹à¦¨à§‹ `@Service` à¦¨à§‡à¦‡
âœ” Spring bean à¦ à¦¿à¦•à¦ à¦¾à¦• inject à¦¹à¦šà§à¦›à§‡

---

## âš ï¸ à¦•à¦¿à¦¨à§à¦¤à§ à¦¸à¦®à¦¸à§à¦¯à¦¾ à¦•à§‹à¦¥à¦¾à§Ÿ?

### ğŸ”´ 1ï¸âƒ£ Scalability Problem

à¦à¦•à¦Ÿà¦¾ service à¦¹à¦²à§‡ à¦ à¦¿à¦• à¦†à¦›à§‡
à¦•à¦¿à¦¨à§à¦¤à§ à§¨à§¦â€“à§©à§¦à¦Ÿà¦¾ service à¦¹à¦²à§‡?

```java
@Bean public AService aService() { }
@Bean public BService bService() { }
@Bean public CService cService() { }
```

âŒ Config class à¦«à§à¦²à§‡ à¦¯à¦¾à¦¬à§‡
âŒ Maintain à¦•à¦°à¦¾ à¦•à¦ à¦¿à¦¨

---

### ğŸ”´ 2ï¸âƒ£ Transaction Risk

```java
@Bean
public PaymentService paymentService() {
    return new PaymentService();
}
```

```java
@Transactional
public void transfer() { }
```

âš ï¸ à¦­à§à¦² proxy à¦¤à§ˆà¦°à¦¿ à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡
ğŸ‘‰ à¦¬à¦¿à¦¶à§‡à¦· à¦•à¦°à§‡ self-invocation à¦¹à¦²à§‡

---

### ğŸ”´ 3ï¸âƒ£ Team / Enterprise Rule Violation

Banking / Enterprise codebase-à¦:

> â€œBusiness services must be annotated with @Serviceâ€

Manual bean = âŒ **code smell**

---

## ğŸŸ¢ à¦¤à¦¾à¦¹à¦²à§‡ manual bean à¦•à¦–à¦¨ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¬?

### âœ” Third-party class

```java
@Bean
public ObjectMapper objectMapper() {
    return new ObjectMapper();
}
```

### âœ” SDK / Client

```java
@Bean
public OkHttpClient httpClient() {
    return new OkHttpClient();
}
```

### âœ” Conditional bean

```java
@Bean
@ConditionalOnProperty(name="cache.enabled", havingValue="true")
public RedisService redisService() { }
```

---

## ğŸ§  Interview One-Liner

> â€œYes, we can define services manually using `@Bean`, but in enterprise applications we prefer `@Service` for clarity, scalability, and consistent AOP behavior. Manual beans are mainly used for infrastructure or third-party components.â€

---

## ğŸ Final Rule of Thumb

| Situation      | Use              |
| -------------- | ---------------- |
| Business logic | `@Service` âœ…     |
| DB access      | `@Repository` âœ…  |
| Infra / SDK    | `@Bean` âœ…        |
| Utility        | static / no bean |

---

à¦šà¦¾à¦“ à¦¤à§‹ next step-à¦ à¦†à¦®à¦¿ à¦¦à§‡à¦–à¦¾à¦¤à§‡ à¦ªà¦¾à¦°à¦¿:

* `@Service` vs `@Bean` **AOP proxy difference**
* Why `@Transactional` fails in self-invocation
* Real banking project config structure

à¦¬à¦²à¦²à§‡à¦‡ à¦¹à¦²à§‹ ğŸš€
