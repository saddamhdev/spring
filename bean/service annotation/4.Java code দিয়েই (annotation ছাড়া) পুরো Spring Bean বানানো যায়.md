рж╣рзНржпрж╛ржБ тЬЕ **Java code ржжрж┐рзЯрзЗржЗ (annotation ржЫрж╛рзЬрж╛) ржкрзБрж░рзЛ Spring Bean ржмрж╛ржирж╛ржирзЛ ржпрж╛рзЯ**ред
ржПржЯрж╛ржХрзЗ ржмрж▓рзЗ **Java-based Configuration**ред

ржЪрж▓ step by step ржжрзЗржЦрж┐ ЁЯСЗ

---

## тЬЕ Way: `@Configuration` + `@Bean` (Pure Java)

### 1я╕ПтГг Service class (ржХрзЛржирзЛ annotation ржирж╛ржЗ)

```java
public class PaymentService {

    public void pay() {
        System.out.println("Payment successful");
    }
}
```

тмЖ ржПржЦрж╛ржирзЗ **@Service / @Component ржХрж┐ржЫрзБржЗ ржирж╛ржЗ**

---

### 2я╕ПтГг Java config ржжрж┐рзЯрзЗ bean ржмрж╛ржирж╛ржирзЛ

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public PaymentService paymentService() {
        return new PaymentService();
    }
}
```

тЮб ржПржЗ method-ржЯрж╛ржЗ bean factory
тЮб method name = bean name (`paymentService`)

---

### 3я╕ПтГг Controller-ржП inject ржХрж░рж╛

```java
@RestController
@RequestMapping("/pay")
public class PaymentController {

    private final PaymentService paymentService;

    public PaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @GetMapping
    public String pay() {
        paymentService.pay();
        return "OK";
    }
}
```

тЬФ App perfectly ржЪрж▓ржмрзЗ
тЬФ Spring-managed bean
тЬФ DI / AOP / Transaction рж╕ржм possible

---

## ЁЯФе Transaction ржУ ржХрж╛ржЬ ржХрж░ржмрзЗ

```java
@Transactional
public class PaymentService {
    public void pay() { }
}
```

тЮб ржХрж╛рж░ржг bean Spring container ржерзЗржХрзЗржЗ ржЖрж╕ржЫрзЗ

---

## ЁЯза рждрж╛рж╣рж▓рзЗ ржкрзНрж░рж╢рзНржи: ржПржЯрж╛ ржХржЦржи ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯ?

### тЬФ Used when:

* Third-party library class
* Annotation modify ржХрж░рж╛ ржпрж╛рзЯ ржирж╛
* Fine-grained control ржжрж░ржХрж╛рж░
* Legacy / banking system

---

## ЁЯПж Banking Project Example

```java
@Bean
public DataSource dataSource() {
    HikariDataSource ds = new HikariDataSource();
    ds.setJdbcUrl("jdbc:postgresql://localhost:5432/bank");
    ds.setUsername("bank");
    ds.setPassword("secret");
    return ds;
}
```

тЮб DataSource-ржП ржХржЦржирзЛ `@Component` ржжрзЗржУрзЯрж╛ рж╣рзЯ ржирж╛
тЮб рж╕ржм Java config ржжрж┐рзЯрзЗржЗ рж╣рзЯ

---

## тЭМ ржХрж┐ржирзНрждрзБ ржХрзЗржи everyday code-ржП ржПржЯрж╛ avoid ржХрж░рж╛ рж╣рзЯ?

| Reason          | Why                  |
| --------------- | -------------------- |
| Boilerplate     | ржмрзЗрж╢рж┐ code            |
| Readability     | ржХржо                   |
| Scalability     | ржХржо convenient        |
| Team convention | `@Service` preferred |

---

## тЬЕ Final Truth (important)

> тЬФ Java code ржжрж┐рзЯрзЗржЗ bean ржмрж╛ржирж╛ржирзЛ ржпрж╛рзЯ
> тЭМ ржХрж┐ржирзНрждрзБ business service-ржПрж░ ржЬржирзНржп `@Service` best practice

---

## ЁЯзк Interview-ready line

> тАЬYes, Spring beans can be created purely using Java configuration via `@Configuration` and `@Bean`.
> This is commonly used for infrastructure or third-party components, while `@Service` is preferred for business logic.тАЭ

---

ржЪрж╛ржУ рждрзЛ ржЖржорж┐ ржкрж░рзЗрж░ржЯрж╛ ржжрзЗржЦрж╛рждрзЗ ржкрж╛рж░рж┐:

* XML config vs Java config vs Annotation (comparison)
* Same bean рждрж┐ржиржнрж╛ржмрзЗ ржмрж╛ржирж╛ржирзЛрж░ demo
* Bean lifecycle with @Bean vs @Service

ржмрж▓рж▓рзЗржЗ рж╣ржмрзЗ ЁЯФе
